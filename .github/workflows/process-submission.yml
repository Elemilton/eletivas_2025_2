name: Processar respostas do formulário

on:
  issues:
    types: [opened]

permissions:
  contents: write
  issues: write

concurrency:
  group: form-submissions
  cancel-in-progress: false

jobs:
  process:
    if: startsWith(github.event.issue.title, '[FORM]')
    runs-on: ubuntu-latest
    steps:
      - name: Process submission via GitHub Script
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            function parseSubmission(body) {
              const m = body.match(/```json\s*([\s\S]*?)\s*```/);
              if (!m) return null;
              try { return JSON.parse(m[1]); } catch(e) { return null; }
            }

            async function getJSON(path, fallback) {
              try {
                const res = await github.rest.repos.getContent({ owner, repo, path });
                const content = Buffer.from(res.data.content, 'base64').toString('utf8');
                return { data: JSON.parse(content), sha: res.data.sha };
              } catch (e) {
                return { data: fallback, sha: null };
              }
            }

            const submission = parseSubmission(issue.body || '');
            if (!submission) {
              await github.rest.issues.createComment({ owner, repo, issue_number: issue.number, body: '❌ Não foi possível ler os dados do formulário.' });
              await github.rest.issues.update({ owner, repo, issue_number: issue.number, state: 'closed', labels: [...(issue.labels||[]).map(l=>l.name), 'invalid'] });
              return;
            }

            const cfg = await getJSON('config/questions.json', { questions: [] });
            const countsObj = await getJSON('data/counts.json', {});
            const respObj = await getJSON('data/responses.json', []);

            const questions = cfg.data.questions || [];
            const counts = countsObj.data || {};
            const responses = respObj.data || [];

            function limitFor(qid, val) {
              const q = questions.find(q => q.id === qid);
              const opt = q?.options?.find(o => o.value === val);
              return opt?.limit ?? Number.POSITIVE_INFINITY;
            }
            function curr(qid, val) { return (counts?.[qid]?.[val]) || 0; }
            function inc(qid, val) { counts[qid] = counts[qid] || {}; counts[qid][val] = (counts[qid][val] || 0) + 1; }

            const increments = [];
            for (const q of questions) {
              const ans = submission.answers?.[q.id];
              if (ans == null) continue;
              if (q.type === 'checkbox') { for (const v of (ans || [])) increments.push({ qid: q.id, val: v }); }
              else { increments.push({ qid: q.id, val: ans }); }
            }

            const violations = [];
            for (const it of increments) {
              const after = curr(it.qid, it.val) + 1;
              const lim = limitFor(it.qid, it.val);
              if (after > lim) { violations.push({ ...it, count: curr(it.qid, it.val), limit: lim }); }
            }

            if (violations.length) {
              const msg = '❌ Algumas opções atingiram o limite e não foram registradas: ' +
                violations.map(v => `${v.qid}/${v.val} (${v.count}/${v.limit})`).join(', ');
              await github.rest.issues.createComment({ owner, repo, issue_number: issue.number, body: msg });
              await github.rest.issues.update({ owner, repo, issue_number: issue.number, state: 'closed', labels: [...(issue.labels||[]).map(l=>l.name), 'rejected'] });
              return;
            }

            for (const it of increments) inc(it.qid, it.val);
            responses.push(submission);

            const enc = (obj) => Buffer.from(JSON.stringify(obj, null, 2)).toString('base64');

            await github.rest.repos.createOrUpdateFileContents({
              owner, repo, path: 'data/responses.json',
              message: `chore: add submission ${submission.id}`,
              content: enc(responses),
              sha: respObj.sha || undefined
            });

            await github.rest.repos.createOrUpdateFileContents({
              owner, repo, path: 'data/counts.json',
              message: `chore: update counts (issue #${issue.number})`,
              content: enc(counts),
              sha: countsObj.sha || undefined
            });

            await github.rest.issues.createComment({ owner, repo, issue_number: issue.number, body: '✅ Sua resposta foi registrada e os limites foram atualizados.' });
            await github.rest.issues.update({ owner, repo, issue_number: issue.number, state: 'closed', labels: [...(issue.labels||[]).map(l=>l.name), 'processed'] });
